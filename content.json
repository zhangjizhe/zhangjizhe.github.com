{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doenpm install hexo-wordcount --save","url":"https://www.zjizhe.cn","root":"/"},"pages":[{"title":"categories","date":"2020-11-18T03:21:46.000Z","updated":"2020-11-18T03:22:00.717Z","comments":false,"path":"categories/index.html","permalink":"https://www.zjizhe.cn/categories/index.html","excerpt":"","text":""},{"title":"测试","date":"2020-11-20T03:27:35.000Z","updated":"2020-11-20T03:27:35.098Z","comments":true,"path":"测试/index-1.html","permalink":"https://www.zjizhe.cn/%E6%B5%8B%E8%AF%95/index-1.html","excerpt":"","text":""},{"title":"测试","date":"2020-12-07T13:41:49.000Z","updated":"2020-12-07T13:41:49.316Z","comments":true,"path":"测试/index-2.html","permalink":"https://www.zjizhe.cn/%E6%B5%8B%E8%AF%95/index-2.html","excerpt":"","text":""},{"title":"测试","date":"2020-11-20T03:27:30.000Z","updated":"2020-11-20T03:27:30.970Z","comments":true,"path":"测试/index.html","permalink":"https://www.zjizhe.cn/%E6%B5%8B%E8%AF%95/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-18T03:20:27.000Z","updated":"2020-11-18T15:02:52.554Z","comments":true,"path":"tags/index.html","permalink":"https://www.zjizhe.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack基础知识点","slug":"webpack","date":"2020-12-07T05:25:00.000Z","updated":"2020-12-07T13:40:29.371Z","comments":true,"path":"webpack/webpack/","link":"","permalink":"https://www.zjizhe.cn/webpack/webpack/","excerpt":"","text":"webpack1.知识点梳理 &amp; 面试题种类 构建流程与构建方式有哪些 plugins 与 loader 区别 分包策略 性能优化 实现多页面打包 不同模块化打包的区别 实现简单的webpack webpack基本的模块打包工具（静态模块），几乎成了前端必备的知识，工作原理是处理应用程序时，会生成依赖关系图，然后打包成bundle。 2.关键词 &amp; 编译流程 模式 mode 入口 entry 出口 output 模块转换器 loader (由于webpack无法处理txt，jpg等，需要loader) 插件 plugins （构建过程中起作用，按照特定逻辑改变结果） 这里大概可以了解下webpack工作流水线，大概流程为 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口： 根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成编译模块：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 3.名词以及基础知识 entry 入口文件，分为三种形式 （string ｜ object ｜ array），分为一对一，一对多，多对多（入口 对 出口）； output 打包输出后的文件，可以指定文件名，也可以用 [name] 变量占位符 loader loader 的执行顺序是从右向左执行的，也就是后面的 loader 先执行,例如常见的[‘style-loader’, ‘css-loader’, ‘less-loader’]，先执行less，然后css，然后style，也符合管道的逻辑，本质上是一个函数 plugin 为了优化构建结果的，提取公共配置，监控资源，热替换等都是插件模式的，插件可以扩展能力 热更新 主要说基于WDS模块热替换，webpack的缩写为HMR，HMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff（chunk 需要更新的部分）。实际上 webpack-dev-server（WDS）与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容（文件列表、hash），这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。后续的部分（拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？）由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。 可以在 config里把devServer 的hot 设为 true。对应入口也要修改if(module &amp;&amp; module.hot) {module.hot.accept()} hash 三种hash，hash、chunkhash、contenthash。hash的生效范围为整个项目，相当于一次构建过程，chunkhash则是根据不同入口文件依赖解析，不影响其他入口生成chunkhash。contenthash则是每个文件唯一的hash sorce map 将编译的代码映射回源代码的过程。map文件不打开开发者工具不会加载。hidden-source-map、nosources-source-map、source map。最后一种可以通过nginx配置map文件只对内网开放","categories":[{"name":"webpack","slug":"webpack","permalink":"https://www.zjizhe.cn/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.zjizhe.cn/tags/webpack/"}],"author":"leif"},{"title":"测试自动部署","slug":"测试自动部署","date":"2020-11-20T06:00:00.000Z","updated":"2020-12-21T05:27:09.260Z","comments":true,"path":"uncategorized/测试自动部署/","link":"","permalink":"https://www.zjizhe.cn/uncategorized/%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"rt","categories":[],"tags":[],"author":"John Doenpm install hexo-wordcount --save"},{"title":"540","slug":"540","date":"2020-11-20T03:07:00.000Z","updated":"2020-11-20T03:25:11.670Z","comments":true,"path":"leetcode/540/","link":"","permalink":"https://www.zjizhe.cn/leetcode/540/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F;递归版本var singleNonDuplicate &#x3D; function (arr) &#123; if (!arr.length) return null; if (arr.length &#x3D;&#x3D;&#x3D; 1) return arr[0]; if (arr.length &#x3D;&#x3D;&#x3D; 3) &#123; if (arr[0] &#x3D;&#x3D; arr[1]) &#123; return arr[2]; &#125; else &#123; return arr[0]; &#125; &#125; let LENGTH &#x3D; arr.length, left &#x3D; [], right &#x3D; [], mid &#x3D; Math.floor(LENGTH &#x2F; 2); if (arr[mid] &#x3D;&#x3D; arr[mid - 1]) &#123; left &#x3D; arr.slice(0, mid - 1); right &#x3D; arr.slice(mid + 1); &#125; else if (arr[mid] &#x3D;&#x3D; arr[mid + 1]) &#123; left &#x3D; arr.slice(0, mid); right &#x3D; arr.slice(mid + 2); console.log(left, right, mid); &#125; else &#123; return arr[mid]; &#125; if (left.length % 2 &#x3D;&#x3D;&#x3D; 0) &#123; return singleNonDuplicate(right); &#125; else &#123; return singleNonDuplicate(left); &#125;&#125;;&#x2F;&#x2F;二分法var singleNonDuplicate1 &#x3D; function (arr) &#123; if (!arr.length) return null; if (arr.length &#x3D;&#x3D;&#x3D; 1) return arr[0]; let l &#x3D; 0, h &#x3D; arr.length - 1, t &#x3D; -1; &#x2F;&#x2F;二分法版本 while (l &lt;&#x3D; h) &#123; let m &#x3D; Math.floor(l + (h - l) &#x2F; 2); if (arr[m] &#x3D;&#x3D;&#x3D; arr[m - 1]) &#123; &#x2F;&#x2F;左边偶 (m - 2) % 2 &#x3D;&#x3D;&#x3D; 0 ? (h &#x3D; m - 2) : (l &#x3D; m + 1); &#125; else if (arr[m] &#x3D;&#x3D;&#x3D; arr[m + 1]) &#123; &#x2F;&#x2F;m%2 为 （m+1）%2好懂一些，取实际长度，这快绕了一下 m % 2 &#x3D;&#x3D;&#x3D; 0 ? (l &#x3D; m + 2) : (h &#x3D; m - 1); &#125; else &#123; return arr[m]; &#125; &#125; return t;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zjizhe.cn/categories/leetcode/"}],"tags":[],"author":"张继哲"},{"title":"34数组排序","slug":"34数组排序","date":"2020-11-20T03:06:00.000Z","updated":"2020-11-20T03:25:18.578Z","comments":true,"path":"leetcode/34数组排序/","link":"","permalink":"https://www.zjizhe.cn/leetcode/34%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F;leetcode 版本&#x2F;** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; *&#x2F;var searchRange &#x3D; function (nums, target) &#123; let res &#x3D; [-1, -1]; let leftIdx &#x3D; searchHelp(nums, target, true); if (leftIdx &#x3D;&#x3D; nums.length || nums[leftIdx] !&#x3D; target) &#123; return res; &#125; res[0] &#x3D; leftIdx; res[1] &#x3D; searchHelp(nums, target, false) - 1; return res;&#125;;function searchHelp(nums, target, isLeft) &#123; let lo &#x3D; 0; let hi &#x3D; nums.length; while (lo &lt; hi) &#123; let mid &#x3D; Math.floor((lo + hi) &#x2F; 2); if (nums[mid] &gt; target || (isLeft &amp;&amp; target &#x3D;&#x3D; nums[mid])) &#123; hi &#x3D; mid; &#125; else &#123; lo &#x3D; mid + 1; &#125; &#125; return lo;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zjizhe.cn/categories/leetcode/"}],"tags":[],"author":"张继哲"},{"title":"快排","slug":"快排","date":"2020-11-20T03:05:00.000Z","updated":"2020-11-20T03:22:23.453Z","comments":true,"path":"算法/快排/","link":"","permalink":"https://www.zjizhe.cn/%E7%AE%97%E6%B3%95/%E5%BF%AB%E6%8E%92/","excerpt":"","text":"123456789101112131415161718192021222324252627282930&#x2F;** * 本质就是设立中间值，然后左右递归，卡在了return那个步骤 * *&#x2F;let arr &#x3D; [85, 24, 63, 45, 17, 31, 96, 50, 2, 5, 22];function qSort(nums) &#123; if (nums.length &lt;&#x3D; 1) &#123; return nums; &#125; let mid &#x3D; Math.floor(nums.length &#x2F; 2); let left &#x3D; []; let right &#x3D; []; let pivot &#x3D; nums.splice(mid, 1)[0]; for (let i &#x3D; 0; i &lt; nums.length; i++) &#123; let item &#x3D; nums[i]; if (item &gt; pivot) &#123; right.push(item); &#125; else &#123; left.push(item); &#125; &#125; console.log(pivot, left, right); return qSort(left).concat([pivot], qSort(right));&#125;let _a &#x3D; qSort(arr);console.log(_a);","categories":[{"name":"算法","slug":"算法","permalink":"https://www.zjizhe.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[],"author":""},{"title":"二叉树","slug":"二叉树","date":"2020-11-20T03:04:00.000Z","updated":"2020-12-20T03:18:15.692Z","comments":true,"path":"算法/二叉树/","link":"","permalink":"https://www.zjizhe.cn/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"算法入门准备从树入手 按照网上读代码理解，目前 remove 还有部分还有不理解下一步骤了解排序问题，跟着 ladadong 学习 2020.12.20 ps:最近看了前中后序遍历，本质是根节点的push时机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138class TreeNode &#123; constructor(data, left, right) &#123; this.data &#x3D; data; this.right &#x3D; right; this.left &#x3D; left; this.count &#x3D; 1; &#125; &#125; class BTree &#123; constructor() &#123; this.root &#x3D; null &#125; _removeNode(node, data) &#123; if (node &#x3D;&#x3D; null) &#123; return null &#125; if (data &#x3D;&#x3D; node.data) &#123; &#x2F;&#x2F;没有双节点 if (node.left &#x3D;&#x3D; null &amp;&amp; node.right &#x3D;&#x3D; null) &#123; return null &#125; &#x2F;&#x2F;没有左节点 if (node.left &#x3D;&#x3D;&#x3D; null) return node.right; &#x2F;&#x2F;没有右节点 if (node.right &#x3D;&#x3D;&#x3D; null) return node.left; &#x2F;&#x2F;有两个节点需要特殊处理 let tempNode &#x3D; this.getMinNode(node.right); node.data &#x3D; tempNode.data; node.right &#x3D; this._removeNode(node.right, tempNode.data) return node; &#125; else if (data &lt; node.data) &#123; node.left &#x3D; this._removeNode(node.left, data); return node &#125; else if (data &lt; node.data) &#123; node.right &#x3D; this._removeNode(node.right, data); return node &#125; &#125; remove(data) &#123; this._removeNode(this.root, data); &#125; insert(data) &#123; let newNode &#x3D; new TreeNode(data, null, null); if (this.root &#x3D;&#x3D; null) &#123; this.root &#x3D; newNode; &#125; else &#123; let currentNode &#x3D; this.root; let parentNode &#x3D; null; while (currentNode) &#123; parentNode &#x3D; currentNode; if (newNode.data &lt; currentNode.data) &#123; currentNode &#x3D; currentNode.left if (!currentNode) &#123; parentNode.left &#x3D; newNode; break; &#125; &#125; else if (newNode.data &gt; currentNode.data) &#123; currentNode &#x3D; currentNode.right if (!currentNode) &#123; parentNode.right &#x3D; newNode break &#125; &#125; else if (newNode.data &#x3D; currentNode.data) &#123; currentNode.count++; break &#125; &#125; &#125; &#125; getMinNode(node &#x3D; this.root) &#123; let currentNode &#x3D; node while (currentNode.left) &#123; currentNode &#x3D; currentNode.left &#125; return currentNode &#125; getMaxNode(node &#x3D; this.root) &#123; let currentNode &#x3D; node while (currentNode.right) &#123; currentNode &#x3D; currentNode.right &#125; return currentNode &#125; find(data) &#123; let currentNode &#x3D; this.root; while (currentNode) &#123; if (currentNode &#x3D;&#x3D; data) &#123; return currentNode &#125; else if (currentNode.data &lt; data) &#123; currentNode &#x3D; currentNode.left; &#125; else if (currentNode.data &gt; data) &#123; currentNode &#x3D; currentNode.right; &#125; &#125; return null &#125; getTotalCount(root &#x3D; this.root) &#123; if (root &#x3D;&#x3D; null) &#123; return 0; &#125; &#x2F;&#x2F; 先算出左右子树有多少节点 let left &#x3D; this.getTotalCount(root.left); let right &#x3D; this.getTotalCount(root.right); &#x2F;* 后序遍历代码位置 *&#x2F; &#x2F;&#x2F; 加上自己，就是整棵二叉树的节点数 let res &#x3D; left + right + 1; return res; &#125; &#125; let myTree &#x3D; new BTree(); let myTree2 &#x3D; new BTree() myTree.insert(20); myTree.insert(13); myTree.insert(7); myTree.insert(9); myTree.insert(15); myTree2.insert(20); myTree2.insert(13); myTree2.insert(7); myTree2.insert(9); myTree2.insert(15); myTree2.remove(7) console.log(myTree) console.log(myTree2) console.log(myTree.getTotalCount()) console.log(myTree2.getTotalCount())","categories":[{"name":"算法","slug":"算法","permalink":"https://www.zjizhe.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.zjizhe.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":""},{"title":"promise实现","slug":"promise实现","date":"2020-11-20T03:02:00.000Z","updated":"2020-11-20T03:04:04.726Z","comments":true,"path":"前端/promise实现/","link":"","permalink":"https://www.zjizhe.cn/%E5%89%8D%E7%AB%AF/promise%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"第一个需要理解的逻辑，是异步调用实质性到 then 时，把执行函数推到数组里，然后延迟调用了函数会取到值，之前一直迷惑是何时塞得，要仔细看代码执行逻辑和顺序，下一步看懂链式调用 ES5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var PENDING &#x3D; &quot;pending&quot;;var FULFILLED &#x3D; &quot;fulfilled&quot;;var REJECTED &#x3D; &quot;rejected&quot;;function Promise(executor) &#123; var self &#x3D; this; self.status &#x3D; PENDING; self.value &#x3D; undefined; self.reason &#x3D; undefined; self.onResolvedCallbacks &#x3D; []; self.onRejectedCallbacks &#x3D; []; function resolve(value) &#123; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.value &#x3D; value; self.status &#x3D; FULFILLED; self.onResolvedCallbacks.forEach((fn) &#x3D;&gt; fn()); &#125; &#125; function reject(reason) &#123; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.reason &#x3D; reason; self.status &#x3D; REJECTED; self.onRejectedCallbacks.forEach((fn) &#x3D;&gt; fn()); &#125; &#125; try &#123; console.log(executor); executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125;&#125;Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123; let self &#x3D; this; if (self.status &#x3D;&#x3D;&#x3D; FULFILLED) &#123; onFulfilled(self.value); &#125; if (self.status &#x3D;&#x3D;&#x3D; REJECTED) &#123; onRejected(self.reason); &#125; if (this.status &#x3D;&#x3D;&#x3D; PENDING) &#123; &#x2F;&#x2F; 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行 this.onResolvedCallbacks.push(() &#x3D;&gt; &#123; onFulfilled(this.value); &#125;); &#x2F;&#x2F; 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行 this.onRejectedCallbacks.push(() &#x3D;&gt; &#123; onRejected(this.reason); &#125;); &#125;&#125;;let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(111); &#125;, 1000);&#125;);p.then( (value) &#x3D;&gt; &#123; console.log(value); &#125;, (reason) &#x3D;&gt; &#123; console.log(&quot;err&quot;, reason); &#125;); A+版本，还需要梳理下，递归那部分比较难理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130var PENDING &#x3D; &quot;pending&quot;;var FULFILLED &#x3D; &quot;fulfilled&quot;;var REJECTED &#x3D; &quot;rejected&quot;;const resolvePromise &#x3D; (promise2, x, resolve, reject) &#x3D;&gt; &#123; if (promise2 &#x3D;&#x3D;&#x3D; x) &#123; return reject( new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;) ); &#125; let called; if ((typeof x &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; x !&#x3D; null) || typeof x &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123; try &#123; let then &#x3D; x.then; if (typeof then &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123; then.call( (x, (y) &#x3D;&gt; &#123; if (called) return; called &#x3D; true; resolvePromise(promise2, y, resolve, reject); &#125;, (r) &#x3D;&gt; &#123; if (called) return; called &#x3D; true; reject(r); &#125;) ); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; resolve(x); &#125; &#125; else &#123; resolve(x); &#125;&#125;;function Promise(executor) &#123; var self &#x3D; this; self.status &#x3D; PENDING; self.value &#x3D; undefined; self.reason &#x3D; undefined; self.onResolvedCallbacks &#x3D; []; self.onRejectedCallbacks &#x3D; []; function resolve(value) &#123; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.value &#x3D; value; self.status &#x3D; FULFILLED; self.onResolvedCallbacks.forEach((fn) &#x3D;&gt; fn()); &#125; &#125; function reject(reason) &#123; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; self.reason &#x3D; reason; self.status &#x3D; REJECTED; self.onRejectedCallbacks.forEach((fn) &#x3D;&gt; fn()); &#125; &#125; try &#123; console.log(executor); executor(resolve, reject); &#125; catch (error) &#123; reject(error); &#125;&#125;Promise.prototype.then &#x3D; function (onFulfilled, onRejected) &#123; onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onFulfilled : (v) &#x3D;&gt; v; onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot; ? onRejected : (error) &#x3D;&gt; &#123; throw error; &#125;; let self &#x3D; this; let promise2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; if (self.status &#x3D;&#x3D; FULFILLED) &#123; setTimeout(() &#x3D;&gt; &#123; try &#123; let x &#x3D; onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0); &#125; if (self.status &#x3D;&#x3D;&#x3D; REJECTED) &#123; setTimeout(() &#x3D;&gt; &#123; try &#123; let x &#x3D; onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0); &#125; if (self.status &#x3D;&#x3D;&#x3D; PENDING) &#123; &#x2F;&#x2F; 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行 self.onResolvedCallbacks.push(() &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; try &#123; let x &#x3D; onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0); &#125;); &#x2F;&#x2F; 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行 self.onRejectedCallbacks.push(() &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; try &#123; let x &#x3D; onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;, 0); &#125;); &#125; &#125;); return promise2;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"手写","slug":"手写","permalink":"https://www.zjizhe.cn/tags/%E6%89%8B%E5%86%99/"}],"author":""},{"title":"flat","slug":"flag","date":"2020-11-20T03:01:00.000Z","updated":"2020-12-02T06:17:14.596Z","comments":true,"path":"前端/flag/","link":"","permalink":"https://www.zjizhe.cn/%E5%89%8D%E7%AB%AF/flag/","excerpt":"","text":"123456789101112131415161718192021222324252627282930let a &#x3D; [1, 2, 3, [3, 4, [5, 6, [7, 8]]]];var myFlat &#x3D; (arr) &#x3D;&gt; &#123; let result &#x3D; []; let help &#x3D; (tempArr) &#x3D;&gt; &#123; for (let index &#x3D; 0; index &lt; tempArr.length; index++) &#123; const element &#x3D; tempArr[index]; console.log(element); if (Array.isArray(element)) &#123; &#x2F;&#x2F;这里细节，当时写的 result.push(help(element)) help(element); &#125; else &#123; result.push(element); &#125; &#125; &#125;; help(arr); return result;&#125;;var flatRe &#x3D; (arr) &#x3D;&gt; &#123; return arr.reduce((prev, next) &#x3D;&gt; &#123; if (Array.isArray(next)) &#123; return prev.concat(flatRe(next)); &#125; else &#123; return prev.concat(next); &#125; &#125;, []);&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"手写","slug":"手写","permalink":"https://www.zjizhe.cn/tags/%E6%89%8B%E5%86%99/"}],"author":""},{"title":"手写bind,apply,call","slug":"手写bind-apply-call","date":"2020-11-20T03:00:00.000Z","updated":"2020-11-20T03:01:39.536Z","comments":true,"path":"前端/手写bind-apply-call/","link":"","permalink":"https://www.zjizhe.cn/%E5%89%8D%E7%AB%AF/%E6%89%8B%E5%86%99bind-apply-call/","excerpt":"","text":"jsliang 的执行有部分问题 参考 https://juejin.im/post/6844903846846676999 123456789101112131415161718192021&#x2F;** * 使用方式 * fn.bind(target) *&#x2F;Function.prototype.myBind &#x3D; function (context) &#123; if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123; throw new TypeError(&quot;Error&quot;); &#125; const _this &#x3D; this; const args &#x3D; [...arguments].slice(1); const result &#x3D; context.fn(...args); return function Fun() &#123; if (this instanceof Fun) &#123; return new _this(...args, ...arguments); &#125; else &#123; return this.apply(context, args.concat(...arguments)); &#125; &#125;;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;** * 使用方式 * fn.call(target, arg1, arg2, ...) * fn.apply(target, [arg1, arg2, ...]) * 区别主要为后续参数 *&#x2F;&#x2F;&#x2F;删除传入函数，返回新函数,流程一样，区别在于参数Function.prototype.myCall &#x3D; function (context) &#123; if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123; throw new TypeError(&quot;Error&quot;); &#125; context &#x3D; context || window; context.fn &#x3D; this; const args &#x3D; [...arguments].slice(1); const result &#x3D; context.fn(...args); delete context.fn; return result;&#125;;Function.prototype.myApply &#x3D; function (context &#x3D; globalThis) &#123; if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123; throw new TypeError(&quot;Error&quot;); &#125; context &#x3D; context || window; context.fn &#x3D; this; console.log(context.fn); let result; if (arguments[1]) &#123; result &#x3D; context.fn(...arguments[1]); &#125; else &#123; result &#x3D; context.fn(); &#125; delete context.fn; console.log(result); return result;&#125;;&#x2F;&#x2F;testfunction Product(name, price) &#123; this.name &#x3D; name; this.price &#x3D; price;&#125;function Food(name, price) &#123; Product.myCall(this, name, price); this.category &#x3D; &quot;food&quot;;&#125;function Food1(name, price) &#123; Product.myApply(this, [name, price]); this.category &#x3D; &quot;food&quot;;&#125;const food &#x3D; new Food(&quot;cheese&quot;, 5);console.log(food);","categories":[{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"手写","slug":"手写","permalink":"https://www.zjizhe.cn/tags/%E6%89%8B%E5%86%99/"}],"author":""},{"title":"订阅发布","slug":"订阅发布","date":"2020-11-20T02:59:00.000Z","updated":"2020-11-20T03:00:14.304Z","comments":true,"path":"前端/订阅发布/","link":"","permalink":"https://www.zjizhe.cn/%E5%89%8D%E7%AB%AF/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637class EventEmitter &#123; constructor() &#123; this.events &#x3D; &#123;&#125;; &#125; on(eventName, callBack) &#123; if (!this.events[eventName]) &#123; this.events[eventName] &#x3D; [callBack]; &#125; else &#123; this.events[eventName].push(callBack); &#125; &#125; emit(eventName) &#123; if (this.events[eventName]) &#123; this.events[eventName].map((fn) &#x3D;&gt; fn()); &#125; &#125; removeListener(eventName, callback) &#123; if (this.events[eventName]) &#123; this.events[eventName] &#x3D; this.events[eventName].filter( (cb) &#x3D;&gt; cb !&#x3D; callback ); &#125; &#125; &#x2F;&#x2F;执行完就移除，以来removeListener once(eventName, callBack) &#123; let fn &#x3D; () &#x3D;&gt; &#123; callBack(); this.removeListener(eventName, fn); &#125;; this.on(eventName, fn); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"手写","slug":"手写","permalink":"https://www.zjizhe.cn/tags/%E6%89%8B%E5%86%99/"}],"author":"张继哲"},{"title":"深拷贝","slug":"深拷贝","date":"2020-11-20T02:58:00.000Z","updated":"2020-11-20T02:59:26.279Z","comments":true,"path":"前端/深拷贝/","link":"","permalink":"https://www.zjizhe.cn/%E5%89%8D%E7%AB%AF/%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"123456789101112131415161718192021222324252627const checkedType &#x3D; (target) &#x3D;&gt; &#123; let result &#x3D; Object.prototype.toString.call(target).slice(8, -1); return result;&#125;;const deepClone &#x3D; (target) &#x3D;&gt; &#123; let result; let type &#x3D; checkedType(target); if (type &#x3D;&#x3D;&#x3D; &quot;Object&quot;) &#123; result &#x3D; &#123;&#125;; &#125; else if (type &#x3D;&#x3D;&#x3D; &quot;Array&quot;) &#123; result &#x3D; []; &#125; else &#123; return target; &#125; for (let i in target) &#123; let value &#x3D; target[i]; if (checkedType(value) &#x3D;&#x3D;&#x3D; &quot;Array&quot; || checkedType(value) &#x3D;&#x3D;&#x3D; &quot;Object&quot;) &#123; result[i] &#x3D; deepClone(value); &#125; else &#123; result[i] &#x3D; value; &#125; &#125; return result;&#125;; 找了些例子，感觉挺简单，可能会有一些坑没避免过去 粗心了，记得判断 type 的函数大小写","categories":[{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"手写","slug":"手写","permalink":"https://www.zjizhe.cn/tags/%E6%89%8B%E5%86%99/"}],"author":"张继哲"},{"title":"阿里云配置 nginx https 总结","slug":"阿里云配置-nginx-https-总结","date":"2020-11-20T02:57:00.000Z","updated":"2020-11-20T03:21:52.857Z","comments":true,"path":"笔记/阿里云配置-nginx-https-总结/","link":"","permalink":"https://www.zjizhe.cn/%E7%AC%94%E8%AE%B0/%E9%98%BF%E9%87%8C%E4%BA%91%E9%85%8D%E7%BD%AE-nginx-https-%E6%80%BB%E7%BB%93/","excerpt":"","text":"阿里云配置 nginx https 总结 安装位置太多额，导致重新安装 命令不熟悉 nginx -t 检测配置状况 nginx -s reload 重启 路径 /etc/nginx/ ftp 工具 FileZilla 阿里云公网 IP 更换地址，改为安全组查看，入口挺深的 深坑一点就是 1.18 版本的。d 目录 default 80 端口文件配置，会被覆盖，找半天，才自己看代码注释掉就好了，百度一堆不靠谱的答案。.. 另一个马虎点，就是配置证书一直以为 ssl 问题，结果是自己注释习惯性用了//, 应该用# apt-get 安装软件 服务器 git 密码 a19920415","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.zjizhe.cn/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/tags/%E5%89%8D%E7%AB%AF/"}],"author":"张继哲"}],"categories":[{"name":"webpack","slug":"webpack","permalink":"https://www.zjizhe.cn/categories/webpack/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zjizhe.cn/categories/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://www.zjizhe.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"笔记","slug":"笔记","permalink":"https://www.zjizhe.cn/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.zjizhe.cn/tags/webpack/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.zjizhe.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"手写","slug":"手写","permalink":"https://www.zjizhe.cn/tags/%E6%89%8B%E5%86%99/"},{"name":"前端","slug":"前端","permalink":"https://www.zjizhe.cn/tags/%E5%89%8D%E7%AB%AF/"}]}